# 가상 메모리


<br>

## | 연속 메모리 할당
*  연속 메모리 할당은 프로세스 내에 연속적인 메모리 공간을 할당하는 방식이라고 한다.
  
<br>

## | 스와핑
* 현재 사용되지 않는 프로세스들을 보조기억장치의 스왑 영역으로 옮기고(스왑 아웃), 새로 생긴 빈 공간에 실행할 프로세스를 적재하는 것(스왑 인)을 말한다.
* 스와핑을 하게 되면, 프로세스들이 요구하는 메모리 공간의 크기가 실제 메모리 크기보다 크더라도 동시에 실행할 수 있다.
* 스왑 영역 크기 확인하기 : free, top

<br>

## | 메모리 할당
* 프로세스가 실행되기 위해서는 메모리 내의 빈 공간에 적재되어야 한다. 
* 연속 메모리 할당 방식에는 `최초 적합, 최적 적합, 최악 적합`이 있다.
  
<br>

#### ■ 최초 적합
* 최초 적합(first-fit)은 운영체제가 메모리 내의 빈 공간을 탐색할 때, 가장 먼저 발견되는 적재 가능 공간에 프로세스를 적재하는 방식이다. 
* 검색을 최소화할 수 있고 할당이 빠르다.
  
#### ■ 최적 적합
* 최적 적합(best-fit)은 운영체제가 매모리 내의 빈 공간을 모두 탐색한 후, 적재 가능한 가장 **작은 공간**에 할당하는 방식
  
#### ■ 최악 적합
* 최악 적합(worst-fit)은 운영체제가 매모리 내의 빈 공간을 모두 탐색한 후, 적재 가능한 가장 **큰 공간**에 할당하는 방식

<br>

## | 외부 단편화
* 프로세스를 메모리에 연속적으로 배치하는 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법이 아니다. <br>
→ `외부 단편화(external fragmentation)`라는 문제 발생
* 외부 단편화는 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
* 외부 단편화는 빈 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고 메모리의 효율성을 떨어뜨림

#### ■ 외부 단편화 해결 방법

① 메모리 압축(compaction)
* 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
* 프로세스를 적당히 재배치시켜 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공가능로 만드는 방법
* 재배치 과정에서 오버헤드가 발생하는 부작용이 있음.

② 가상 메모리 기법, 페이징

<br>

## | 가상 메모리
* 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
* 페이징, 세그멘테이션

<br>

## | 페이징
* 외부단편화의 근본적인 문제는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문
* 페이징은 외부단편화를 해결하기 위해  프로세스를 일정한 크기로 나누고, 불연속적으로 메모리에 적재하는 방식이다. 
* 프로세스의 논리 주소 공간을 `페이지`라는 일정 단위로 자르고, 메모리의 물리 주소 공간을 `프레임`이라는 일정한 단위로 나눈 뒤 페이지를 프레임에 할당하는 방식이다.

#### ■ 페이징에서의 스와핑
* 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)
* 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
* 실행에 필요한 페이지들은 메모리로 스왑 인
* 프로세스를 실행하기 위해 모든 페이지가 적재될 필요 없음
* 달리 말해, 물리 메모리보다 큰 프로세스도 실행될 수 있음

#### ■ 페이징의 문제
* 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지 CPU가 일일이 알기란 어려움
* 프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수가 없음
* CPU 입장에서 '다음에 실행할 명령어 위치'를 찾기가 어려워짐

#### ■ 페이지 테이블
* (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법
* 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
* 프로세스마다 페이지 테이블이 존재
* 물리적으로는 분산되어 저장되어 있더라도 CPU 입장에서 바라본 논리 주소는 연속적으로 보임
* CPU는 그저 논리 주소를 순차적으로 실행하면 됨

#### ■ 내부단편화
* 페이지 크기가 10KB, 프로세스 크기 108KB?
* 2KB는 내부 단편화
* 하나의 페이지 크기보다 작은 크기로 발생


<br>

## | PTBR
* 프로세스마다 페이지 테이블이 있고, 각 페이지 테이블은 CPU 내의 `프로세스 테이블 베이스 레지스터(PTBR)`가 가리킴
* 페이지 테이블을 메모리에 두게 되면, 메모리 접근 시간이 두 배로 늘어나게 됨
  * 페이지 테이블 참조하기 위해 한번
  * 페이지 참조하기 위해 한번

<br>

## | TLB
* PTBR의 메모리 접근 시간을 해결하기 위해서 `TLB(Translation Lookaside Buffer)`를 사용
  * TLB는 페이지 테이블의 캐시 메모리
  * 페이지 테이블의 일부 내용을 저장
  * TLB에는 최근에 사용된 페이지 위주로 저장
* CPU가 접근하려는 논리 주소가 TLB에 있을 경우 이를 TLB 히트(메모리 접근 한번), 없을 경우 TLB 미스라고 함(메모리 접근 두번)

<br>

## | 페이징에서의 주소 변환
* 특정 주소에 접근하기 위해서는 어떤 페이지 혹은 프레임에 접근하고 싶은지, 접근하려는 주소가 그 페이지 혹은 프레임에서 얼마나 떨어져 있는지를 알아야 함
* 페이징 시스템에서의 **논리 주소**는 <페이지 번호(page number), 변위(offset)>로 구성된다. 이는 페이지 테이블을 통해 **물리 주소** <프레임 번호, 변위>로 변환됨
* 논리주소 상의 변위와 물리 주소상의 변위는 같음

<br>

## | 페이지 테이블 엔트리(PTE)
* 페이지 테이블 엔트리는 페이지 테이블의 각 행을 의미한다. 페이지 번호와 프레임 번호 외의 정보도 포함한다.

`유효 비트` 
* 현재 해당 페이지에 접근 가능한지 여부를 알려준다. 
* 유효비트가 0이면 해당 페이지는 메모리에 적재되어 있지 않다. 
* 유효비트가 0인 페이지에 접근하려고 하면 페이지 폴트 인터럽트가 발생
  * CPU는 기존의 작업 내역을 백업
  * 페이지 폴트 처리 루틴을 실행
  * 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경
  * 페이지 폴트를 처리했다면 이제 CPU는 해당 페이지에 접근 가능함

`보호 비트` : 
* 페이지 보호를 위한 비트이다. 
* 보호 비트가 0이면 읽기 전용, 1이면 읽기/쓰기가 가능하다.

`참조 비트` : 
* CPU가 해당 페이지에 접근했는지 여부를 알려준다. 
* 참조 비트가 0이면 해당 페이지에 접근하지 않았다.

`수정 비트` : 
* CPU가 해당 페이지에 데이터를 쓴 적이 있는지 여부를 알려준다. 
* 수정 비트가 0이면 해당 페이지에 쓰기 접근하지 않았다.
* 수정된 페이지는 스왑 아웃될 때 보조기억장치에도 쓰기 작업을 거쳐야하는데 이때 수정비트를 통해 판단함.
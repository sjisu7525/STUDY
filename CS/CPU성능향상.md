# CPU 성능 향상

# 5.1 빠른 CPU를 위한 설계 기법

## 클럭
- 클럭 속도가 높은 CPU는 일반적으로 성능이 좋으나 클럭을 높이면 발열이 심각해짐.
- 클럭 속도를 늘리는 방법 이외에 CPU를 빠르게 동작시키는 방법은 두 가지가 있음
  - 코어 수를 늘리는 방법
  - 스레드 수를 늘리는 방법

<br>

## 코어와 멀티코어
#### ■ 코어
- 코어는 명령어를 실행하는 부품이고, CPU는 명령어를 실행하는 부품을 여러 개 포함한 부품으로 정의할 수 있음
- 코어를 두 개 이상 포함하고 있는 CPU는 멀티코어 CPU 또는 멀티코어 프로세서라고 부름
- 코어를 늘리면 좋지만, CPU의 연산 속도가 꼭 코어 수에 비례하여 증가하지는 않으므로 적절히 분배하는 것이 중요함

<br>

## 스레드와 멀티 스레드
- 스레드 : 실행 흐름의 단위
- 스레드에는 CPU에서 사용되는 하드웨어적 스레드와 프로그램에서 사용되는 소프트웨어적 스레드가 있음

#### ■  하드웨어적 스레드(논리 프로세서)
- 스레드를 하드웨어적으로 정의하면 '하나의 코어가 동시에 처리하는 명령어 단위'를 의미함
- 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 프로세서 또는 멀티스레드 CPU라고 함
- 하이퍼스페딩은 인텔의 멀티스레드 기술을 의미
- 멀티스레드 프로세서의 핵심은 레지스터임
  - 하나의 코어가 레지스터들을 여러개 가지고 있다면 멀티스레드 프로세서를 설계할 수 있음

#### ■ 소프트웨어적 스레드
- 소프트웨어적으로 정의된 스레드는 '하나의 프로그램에서 독립적으로 실행되는 단위'를 의미힌다.
- 1코어 1스레드 CPU도 여러 소프트웨어적 스레드를 만들 수 있음


```
✅ 참고
- 코어는 명령어를 실행할 수 있는 '하드웨어 부품'이고, 스레드는 '명령어를 실행하는 단위'이다. 
- 멀티코어 프로세서는 명령어를 실행할 수 있는 하드웨어 부품이 CPU안에 두 개 이상 있는 CPU를 의미하고, 멀티스레드 프로세서는 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU를 의미한다.
```
<br>
<br>

# 5.2 명령어 병렬 처리 기법

## 명령어 파이프라인
- 단계 순서 : 명령어 인출 > 명령어 해석 > 명령어 실행 > 결과 저장
- 명령어 파이프라이닝 : 같은 단계가 겹치지만 않는다면 CPU는 각 단계를 동시에 실행할 수 있음
- 파이프라인 위험 : 명렁어 파이프라인이 성능 향상에 실패하는 경우(명령어 파이프라이닝이 불가능한 경우)
  - 데이터 위험, 제어위험, 구조적 위험으로 구분됨

#### ■ 데이터 위험
- 명령어 간 '데이터 의존성'에 의해 발생한다.
- 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않은 것을 데이터 위험이라고 한다.

#### ■ 제어 위험
- 주로 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생한다.
- 분기 예측을 통해 막을 수 있다.

#### ■ 구조적 위험
- 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 같은 CPU 부품을 사용하려고 할 때 발생한다.
- 구조적 위험은 자원 위험이라고도 불린다.

<br>

## 슈퍼스칼라
- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 슈퍼 스칼라라고 한다.
- 슈퍼스칼라 프로세서는 이론적으로 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라진다.
  - 그러나 실제로 파이프라인 개수가 증가하면 파이프라인 위험도의 증가로 인해 파이프라인 개수에 비례하여 처리 속도가 증가하지는 않는다.

<br>

## 비순차적 명령어 처리
- 비순차적 명령어 처리(OoOE : Out of Order Execution)는 명령어를 순차적으로 실행하지 않는 기법이다.

<br>
<br>

# 5.3 CISC와 RISC

## 명령어 집합
- CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합(Instruction Set) 또는 명령어 집합 구조(ISA : Instruction Set Architecture)이라 한다. 
- 같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다는 것이다. 
- CPU는 명령어 집합에 속해 있는 명령어만 이해할 수 있다.
  - 즉, ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할 지에 대한 약속이다. 
  - 명령어 집합의 두 축 : `CISC`와 `RISC`

<br>

## CISC
- CISC(Complex Instruction Set Computer)은 '복잡한 명령어 집합을 활용하는 컴퓨터'이다. 
- CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어 형태와 크기가 다양한 가변 길이 명령어를 활용한다.
- 메모리 공간을 절약할 수 있다는 장점이 있지만, 파이프라이닝이 불리하다는 단점을 가지고 있다. (명령어 규격화가 어렵다.)

<br>

## RISC
- RISC(Reduced Instruction Set Computer)는 고정 길이 명령어를 활용하고, CISC와 다르게, 명령어는 짧고 규격화되어 있으며, 1클럭 내외로 실행되는 명령어를 지향한다. 
- 명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에, RISC 명령어 집합은 명령어 파이프라이닝에 최적화되어 있다.
- RISC는 메모리 접근을 단순화하고 최소화하는 대신 범용 레지스터를 적극적으로 활용한다. 
- CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다. 다만 사용 가능한 명령어 개수가 CISC보다 적기 때문에 RISC는 CISC보다 많은 명령으로 프로그램을 작동시킨다.

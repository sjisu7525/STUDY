# CPU 스케줄링
## | CPU 스케줄링 개요
* 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것

<br>

## | 프로세스 우선순위
* 프로세스의 우선순위를 고려하여 CPU 스케줄링을 진행
  * 입출력 작업이 많은 프로세스(=입출력 집중 프로세스)의 우선순위는 CPU 작업이 많은 프로세스(=CPU 집중 프로세스)의 우선순위보다 높음
* 이러한 프로세스의 우선순위는 PCB에 작성되어 있음
  * 리눅스에서는 ps -el 명령어를 통해 우선순위 확인이 가능하다.
  * 리눅스는 nice 명령어를 통해 일부 프로세스 우선순위를 변경할 수 있음
  * 윈도우는 별도의 소프트웨어를 통해 우선순위 확인과 변경이 가능함(Process Explorer).
* 그러나 운영체제가 모든 PCB를 확인하며 우선순위를 파악하는 것은 비효율적

<br>

### ■ 스케줄링 큐
---

* 프로세스들은 사용할 자원을 요청하고, 해당 자원의 대기줄에서 허가 응답을 기다림
  * 여기서 큐는 일반적인 큐와 달리 선입선출일 필요는 없음
* 운영체제는 자원을 큐로 관리하고, 대표적으로 `준비 큐`와 `대기 큐`가 존재

#### 준비 큐와 대기 큐

`준비 큐` <br>
* 준비 상태에 있는 프로세스의 PCB는 준비 큐에 삽입돼 CPU 사용을 기다린다.
* 운영체제는 PCB들이 삽입된 순서대로 프로세스를 인출하나, 우선순위가 높은 프로세스는 먼저 실행한다.
* 즉, 우선순위가 낮은 프로세스보다 높은 프로세스가 순서보다 먼저 처리될 수 있다.

`대기 큐` <br>
* 같은 입출력장치를 요구한 프로세스들은 같은 대기 큐에 존재한다.
* 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB를 대기 큐에서 제거하고 준비 큐에 이동한다.

<br>
<p align="center">
<img src="../_img/스케줄링 큐.png" width="" height="300" /> </center>
<img src="../_img/프로세스 상태 다이어그램.png" width="" height="300" /> </center>
</p>
<br> 

<br>

### ■ 선점형과 비선점형 스케줄링
---


#### 선점형 스케줄링(preemptive scheduling)

* 프로세스가 자원을 사용하더라도 운영체제가 해당 프로세스로부터 자원을 강제로 뺏어 다른 프로세스에 할당할 수 있는 스케줄링 방식
* 하나의 프로세스는 자원을 독점할 수 없음
* 보통 프로세스마다 특정 시간만큼 자원을 사용하고, 시간이 지나면 타이머 인터럽트가 발생
* 타이머 인터럽트가 발생하면 CPU는 자원을 빼앗아 다른 프로세스에 할당
* 현재는 대부분 선점형 스케줄링 방식을 차용

✅장점 <br>
* 특정 프로세스의 자원 독점을 막고, 프로세스에 자원을 골고루 배분할 수 있음

❎단점 <br>
* 문맥 교환 과정에서 오버헤드가 발생
 
<br> 

#### 비선점형 스케줄링(non-preemptive scheduling)

* 하나의 프로세스가 사용이 종료되거나 스스로 대기상태로 변경되기 전까진 다른 프로세스가 해당 자원을 사용할 수 없는 스케줄링 방식
* 프로세스는 자원 사용을 독점할 수 있음
* 동일한 자원을 요구하는 다른 프로세스들은 특정 프로세스의 자원 사용이 끝날 때 까지 대기해야 함
 
✅장점<br>
* 문맥 교환 횟수가 적어 오버헤드 발생이 적음

❎단점<br>
* 프로세스들이 자원을 골고루 활용할 수 없음

<br>

## | CPU 스케줄링 알고리즘

### ■ 선입 선처리 스케줄링
---
* FCFS (First Come First Served)
* 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링
* 먼저 CPU를 요청한 프로세스부터 CPU 할당
* 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 단점 존재(호위효과)

### ■ 최단 작업 우선 스케줄링
---
* SJF (Shortest Job First)
* 호위효과를 방지하기 위해
  * CPU 사용이 긴 프로세스는 나중에 실행
  * CPU 사용 시간이 짧은 프로세스는 먼저 실행

### ■ 라운드 로빈 스케줄링
---
* RR (Round Robin)
* 선입 선처리 스케줄링 + 타임 슬라이드 (time slice)
* 타임 슬라이스란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
* 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링
* 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입 (문맥 교환)
* 타임 슬라이스의 크기가 중요


### ■ 최소 잔여 시간 우선 스케줄링
---
* SRT (Shortest Remaining Time)
* 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
  * 최단 작업 우선 스케줄링
    * 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘
  * 라운드 로빈 스케줄링
    * 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘
* 정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스 선택

### ■ 우선순위 스케줄링
---
* 프로세스들에 우선순위를 부여, 우선순위 높은 프로세스부터 실행
* 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
* 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 ⊂ 우선순위 스케줄링

* 근본적인 문제점인 `기아(starvation)` 현상
  * 우선순위 높은 프로세스만 주구장창 실행하고, 우선순위 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 실행 연기
* 방지 기법으로 `에이징(aging)`이 있음
  * 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
  * 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방법
  * 우선순위가 낮아도 언젠가는 우선순위가 높아진다


### ■ 다단계 큐 스케줄링
---
* multilevel queue
* 우선순위 스케줄링의 발전된 형태
* 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
  * 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
  * 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스 처리
* 기본적으로 큐 간의 이동 불가
  * 우선순위가 낮은 프로세스는 계속해서 실행 연기 우려
  * 기아 현상 발생 가능

### ■ 다단계 피드백 큐 스케줄링
---
* multilevel feedback queue
* 다단계 큐 스케줄링의 발전된 형태로 큐 간의 이동이 가능
* 타임 슬라이스 동안 실행이 끝나지 않는다면 낮은 우선순위 큐로 이동
  * 자연스럽게 CPU 집중 프로세스의 우선 순위는 상대적으로 낮아지고 입출력 집중 프로세스의 우선순위는 상대적으로 높아짐
* 에이징 기법 적용 가능
* 즉 어떤 프로세스의 CPU 시간이 길면 우선순위가 낮아지고 어떤 프로세스가 낮은 우선순위 큐에서 너무 오래 기다리면 우선순위를 높이는 방식
* CPU 스케줄링 방식으로 알려져 있음
# 명령어 

# 3.1 소스코드와 명령어

## 고급 언어, 저급 언어

#### ■ 고급 언어(high-level programming language)
- 사람이 이해하고 작성하기 쉽게 만들어진 언어
  - 예) C, C++, Java, Python, ...

#### ■ 저급 언어(low-level programming language)
- 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- '명령어'로 이루어져 있다.
- 고급 언어로 작성된 코드가 실행되려면 반드시 저급 언어로 변환되어야 한다.
- 저급 언어의 종류 : `기계어`와 `어셈블리어`

#### ■ 고급언어가 저급언어로 변환되는 과정 
- `컴파일 언어`와 `인터프리터 언어`가 있음
  
<br>

### | 기계어
- 0과 1의 명령어 비트로 이루어진 언어
- 다만, 이진수로 나열하면 너무 길어지기 때문에 가독성을 위해 십육진수로 변환하기도 한다.

<br>

### | 어셈블리어
- 명령어(기계어)를 읽기 편한 형태로 번역한 저급 언어
  - 예) push rdp, ret, pop rdp, ...
- 기계어를 읽기 쉬운 수준으로 변환한 언어일 뿐 실제로 어셈블리어를 이용해 복잡한 프로그램을 만드는 것은 쉽지 않다. 
- 따라서 가독성도 더 좋고 편리한 문법이 제공되는 고급 언어를 사용하여 개발하는 것이 실무적 관점에서 유용하다.

#### ■ 어셈블리어가 중요한 분야
- 하드웨어와 밀접하게 맞닿아 있는 프로그램을 개발하는 임베디드 개발자, 게임 개발자, 정보 보안 분야 등의 개발자는 어셈블리어를 많이 사용함
  - 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 프로그램이 어떤 절차로 작동되는지를 가장 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있기 때문
- 개발을 입문하는 단계에서는 고급언어-저급언어의 차이를 이해하는 것은 매우 좋은 교양이기 때문에 입문자라면 반드시 알아두는 것이 좋다.


<br>

### | 컴파일 언어
- 컴파일 언어 : 컴파일러에 의해 **코드 전체**가 저급 언어로 변환되어 실행되는 언어
- 컴파일 : 코드 전체가 저급 언어로 변환되는 과정
- 컴파일러 : 컴파일을 수행해주는 도구
- 목적코드 : 컴파일러를 통해 저급 언어로 변환된 코드
- 문법오류, 실행 가능성, 불필요한 코드 체크 후 모든 코드를 처음부터 끝까지 저급 언어로 컴파일
- 오류를 하나라도 발견하면 해당 소스 코드는 컴파일에 실패한다.
- 대표적인 언어 : C
  
<br>

### | 인터프리터 언어
- 인터프리터 언어 : 인터프리터에 의해 소스 코드가 **한 줄씩** 차례로 저급언어로 변환하여 실행되는 언어
- 인터프리터 : 소스 코드를 한 줄 씩 변환하여 실행해주는 도구
- 컴퓨터와 대화하듯 소스 코드를 한 줄씩 실행하기 때문에 소스 코드 전체를 변환하는 시간을 기다릴 필요가 없다.
- 대신 런타임에 소스 코드 마지막에 이를 때까지 한 줄 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문에 컴파일 언어보다 느리다.
- 소스 코드를 한 줄씩 실행하기 때문에, 소스 코드 N번째 줄에 문법 오류가 있더라도 N-1번줄까지는 올바르게 수행된다.
- 대표적인 언어 : Python

<br>

#### 💡 컴파일 언어, 인터프리터 언어의 경계가 모호한 경우가 있음
```
- C, C++과 같이 명확하게 특정 방식의 언어라고 단언할 수 있는 언어도 있으나, 현대의 많은 프로그래밍 언어 중에는 컴파일 언어 - 인터프리터의 경계가 모호한 경우가 더 많음
- Python도 컴파일을 하지 않는 것은 아님
- Java는 저급 언어로 번역하는 과정에서 컴파일과 인터프리트를 동시에 수행
- 고급언어가 저급 언어로 변환되는 대표적인 방법에는 컴파일 방식과 인터프리트 방식이 있다 정도로만 이해
```
<br>

# 3.2 명령어의 구조
- 명령어는 `연산코드`와 `오퍼랜드`로 구성됨

### | 오퍼랜드
- 연산에 사용될 데이터나 연산에 사용될 데이터가 저장된 위치
- 오퍼랜드 필드를 주석 필드라고 부르기도 함
- 오퍼랜드가 0개인 경우도 있고, 하나 이상인 경우도 있음
  
<br>

### | 연산코드
- 크게 4가지 존재 `데이터전송` `산술/논리연산` `제어 흐름 변경` `입출력 제어`

#### ■ 데이터 전송
- `MOVE` : 데이터를 옮겨라
- `STORE` : 메모리에 저장하라
- `LOAD(FETCH)` : 메모리에서 cpu로 데이터를 가져와라
- `PUSH` : 스택에 데이터를 저장하라
- `POP` : 스택의 최상단 데이터를 가져와라

#### ■ 산술/논리 연산
- `ADD/SUBTRACT/MULTIPLY/DIVIDE` : 덧셈/뺄셈/곱셈/나눗셈을 수행하라
- `INCREMENT/DECREMENT` : 오퍼랜드에 1을 더라하 / 오퍼랜드에 1을 빼라
- `AND/OR/NOT` : AND/OR/NOT 연산 수행하라
- `COMPARE` : 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라

#### ■ 제어 흐름 변경
- `JUMP` : 특정 주소로 실행 순서를 옮겨라
- `CONDITIONAL JUMP` : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
- `HALT` : 프로그램의 실행을 멈춰라
- `CALL` : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라 
- `RETURN` : CALL을 호출할 때 저장했던 주소로 돌아가라 

#### ■ 입출력 제어
- `READ(INPUT)` : 특정 입출력 장치로부터 데이터를 읽어라
- `WRITE(OUTPUT)` : 특정 입출력 장치로 데이터를 써라
- `START IO` : 입출력 장치를 시작하라
- `TEST IO` : 입출력 장치의 상태를 확인하라


<br>

### | 명령어 주소 지정 방식
- 명령어 주소 지정 방식
  - 연산에 사용할 데이터가 저장된 위치를 찾는 방법
  - 유효 주소(연산에 사용될 데이터가 저장된 위치)를 찾는 방법
  - 다양한 명령어 주소 지정 방식들

#### ■ 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 가장 간단한 형태의 주소 지정 방식
- 연산에 사용할 데이터의 크기가 작아질 수 있지만, 빠름

#### ■ 직접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소 직접적으로 명시
- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듦


#### ■ 간접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소의 주소를 명시
- 앞선 주소 지정 방식들에 비해 속도가 느림
  
#### ■ 레지스터 주소 지정 방식
- 연산에 사용할 데이터가 저장된 레지스터 명시
- 메모리에 접급하는 속도보다 레지스터에 접근하는 것이 빠름

#### ■ 레지스터 간접 주소 지정 방식
- 연산에 사용할 데이터를 메모리에 저장
- 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시

<br>

### | C 언어 컴파일 과정
- 전처리기 > 컴파일러 > 어셈블러 > 링커

#### ■ 전처리 과정
- 본격적으로 컴파일하기 전에 처리할 작업들
- 외부에 선언된 다양한 소스 코드, 라이브러리 포함
- 프로그래밍의 편의를 위해 작성된 매크로 변환
- 컴파일할 영역 명시

#### ■ 컴파일 과정
- 전처리가 완료 되어도 여전히 소스코드(고급언어)
- 전처리 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환

#### ■ 어셈블 과정
- 어셈블리어를 기계어로 변환
- 목적 코드를 포함하는 목적 파일이 됨

```
✅ 목적 파일 vs 실행 파일
- 목적 파일과 실행 파일은 둘 다 기계어로 이루어진 파일
- 그러나 목적 파일과 실행 파일은 서로 다름
- 목적 파일은 링킹을 거친 이후에야 실행파일이 됨
```
```
✅ 링킹
- 목적 코드가 실행 파일이 되기 위해서는 '링킹' 작업을 거쳐야 한다.
- 다른 목적에 분리된 외부 기능들을 연결 짓는
작업이 필요 
- 링킹 작업까지 모두 거쳐야 실행 파일이 만들어짐
```